<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Download Cached Data to CSV</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    button { padding: 0.6rem 1rem; font-size: 1rem; cursor: pointer; }
    .status { margin-top: 1rem; color: #444; }
    .error { color: #b00020; }
  </style>
</head>
<body>
  <h1>Download cached data to CSV</h1>
  <p>This reads <code>/custom/addbookdata.json</code> from the Cache API, filters entries with non-empty <code>name</code>, and downloads a CSV.</p>

  <button id="downloadBtn">Download CSV</button>
  <div id="status" class="status"></div>

  <script>
    // Utility: safely get a flat string value for CSV from any JS value
    function toFlatString(value) {
      if (value == null) return "";
      if (typeof value === "object") {
        try {
          return JSON.stringify(value);
        } catch {
          return String(value);
        }
      }
      return String(value);
    }

    // Utility: escape a single CSV cell (RFC4180-ish)
    function escapeCsvCell(cell) {
      const needsQuotes = /[",\n\r]/.test(cell);
      let escaped = cell.replace(/"/g, '""');
      return needsQuotes ? `"${escaped}"` : escaped;
    }

    // Build CSV from array of objects
    function toCsv(rows) {
      if (!Array.isArray(rows) || rows.length === 0) {
        return "name\n"; // minimal header if no data
      }

      // Collect all unique keys across rows to form a stable header
      const headerSet = new Set();
      rows.forEach(row => {
        Object.keys(row || {}).forEach(k => headerSet.add(k));
      });
      const headers = Array.from(headerSet);

      const lines = [];
      // Header line
      lines.push(headers.map(h => escapeCsvCell(h)).join(","));

      // Data lines
      for (const row of rows) {
        const cells = headers.map(h => escapeCsvCell(toFlatString(row?.[h])));
        lines.push(cells.join(","));
      }

      return lines.join("\r\n");
    }

    async function getFilteredDataFromCache() {
      // Your provided snippet, wrapped safely
      const response = await caches.match('/custom/addbookdata.json');
      if (!response) return [];

      const json = await response.json().catch(() => null);
      if (!Array.isArray(json)) return [];

      const ibradata = json.filter(b => (b?.name ?? "") !== "");
      return ibradata;
    }

    async function downloadCsv() {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Reading cacheâ€¦";

      try {
        const data = await getFilteredDataFromCache();

        if (!data.length) {
          statusEl.innerHTML = "<span class='error'>No data found in cache or all entries have empty name.</span>";
          return;
        }

        const csv = toCsv(data);

        // Add BOM for better Excel compatibility
        const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "ibradata.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        statusEl.textContent = `Downloaded ${data.length} rows to ibradata.csv`;
      } catch (err) {
        console.error(err);
        statusEl.innerHTML = "<span class='error'>Failed to generate CSV. Check console for details.</span>";
      }
    }

    document.getElementById("downloadBtn").addEventListener("click", downloadCsv);
  </script>
</body>
</html>
